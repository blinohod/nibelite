#!/usr/bin/env perl

use strict;
use warnings;
use 5.8.0;

use lib '/opt/nibelite/lib/perl';

NibeliteAuth->run();

1;

package NibeliteAuth;

use Nibelite::SQL;
use Digest::MD5 qw(md5_hex);
use IO::Prompt;
use base 'Nibelite::App::CLI';

sub listing {
	my ( $this, $row, $order, $delimiter ) = @_;
	unless ($delimiter) {
		$delimiter = '|';
	}
	my @buf;
	foreach my $key (@$order) {
		unless ( defined( $row->{$key} ) ) {
			$row->{$key} = "";
		}
		$row->{$key} =~ s/\n/\\n/g;
		$row->{$key} =~ s/\r/\\r/g;
		$row->{$key} =~ s/\\/\\\\/g;
		$row->{$key} =~ s/\|/\\|/g;
		push @buf, $row->{$key};
	}
	return join( $delimiter, @buf );
}

sub action_users_list {
	my ( $this, %params ) = @_;
	my $filter = ( defined( $params{__non_options__} ) and $params{__non_options__} ) || [];
	my $sql = Nibelite::SQL->select(
		fields => {
			id      => 'cu.id',
			login   => 'cu.login',
			active  => 'cu.active',
			name    => 'cu.name',
			created => "to_char(cu.created, 'YYYY-MM-DD')",
			expire  => "to_char(cu.expire, 'YYYY-MM-DD')",
			email   => "cu.email",
			descr   => "cu.descr"
		},
		tables => { 'cu' => 'core.users' },
		order => [ [ 'login', 'asc' ] ]
	);

	if ( $params{active} ) {
		$sql->where( ["cu.active"] );
	}

	if ( $params{inactive} ) {
		$sql->where( ["NOT cu.active"] );
	}

	if ( $params{group} ) {
		$sql->joins(
			[
				'JOIN core.users_groups cug ON (cug.user_id = cu.id)',
				'JOIN core.groups cg ON (cug.group_id = cg.id)'
			]
		);
		if ( $params{group} =~ /^\d+$/ ) {
			$sql->where( ["cg.id = :group_id"] );
			$sql->params( { group_id => $params{group} } );
		} else {
			$sql->where( ["cg.group_name = :group_name"] );
			$sql->params( { group_name => $params{group} } );
		}
	}

	if ( scalar(@$filter) ) {
		my $i = 0;
		foreach my $f (@$filter) {
			$sql->where( ["cu.login ILIKE :term_$i OR cu.email ILIKE :term_$i OR cu.name ILIKE :term_$i OR cu.descr ILIKE :term_$i"] );
			$f =~ s/([%_])/\\$1/g;
			$sql->params( { "term_$i" => "%$f%" } );
			$i++;
		}
	}

	my $sth = $sql->find( $this->dbh );
	my $order = [ 'id', 'login', 'active', 'name', 'created', 'expire', 'email', 'descr' ];
	my @buf;
	print STDOUT join( "|", @$order ) . "\n";
	while ( my $row = $sth->fetchrow_hashref() ) {
		if ( $row->{active} ) {
			$row->{active} = 'true';
		} else {
			$row->{active} = 'false';
		}
		print STDOUT $this->listing( $row, $order ) . "\n";
	}

} ## end sub action_users_list

sub action_groups_list {
	my ( $this, %params ) = @_;
	my $filter = ( defined( $params{__non_options__} ) and $params{__non_options__} ) || [];
	my $sql = Nibelite::SQL->select(
		fields => {
			id         => 'cg.id',
			group_name => 'cg.group_name',
		},
		tables => { 'cg' => 'core.groups' },
		order => [ [ 'group_name', 'asc' ] ]
	);

	if ( $params{user} ) {
		$sql->joins(
			[
				'JOIN core.users_groups cug ON (cug.group_id = cg.id)',
				'JOIN core.users cu ON (cug.user_id = cu.id)'
			]
		);
		if ( $params{user} =~ /^\d+$/ ) {
			$sql->where( ["cu.id = :user_id"] );
			$sql->params( { user_id => $params{user} } );
		} else {
			$sql->where( ["cu.login = :user_name"] );
			$sql->params( { user_name => $params{user} } );
		}
	}

	if ( scalar(@$filter) ) {
		my $i = 0;
		foreach my $f (@$filter) {
			$sql->where( ["cg.group_name ILIKE :term_$i"] );
			$f =~ s/([%_])/\\$1/g;
			$sql->params( { "term_$i" => "%$f%" } );
			$i++;
		}
	}

	my $sth = $sql->find( $this->dbh );
	my $order = [ 'id', 'group_name' ];
	my @buf;
	print STDOUT join( "|", @$order ) . "\n";
	while ( my $row = $sth->fetchrow_hashref() ) {
		print STDOUT listing( $row, $order );
	}

} ## end sub action_groups_list

sub action_user_add {
	my ( $this, %params ) = @_;
	my $username = undef;
	my $field_map = { password => 'MD5(?)' };
	if ( defined( $params{__non_options__} ) && scalar( @{ $params{__non_options__} } ) ) {
		$username = $params{__non_options__}->[0];
	} else {
		$this->speak('Error: user-add: missing login name');
		$this->exitcode(1);
		return undef;
	}
	unless ( defined( $params{password} ) ) {
		$this->speak('Warning: password not set, using autogenerated one');
		$params{password} = md5_hex( rand() );
	}
	my @fields       = ('login');
	my @values       = ( $username, );
	my @placeholders = ( '?', );
	foreach my $field (qw(password email descr name active expire)) {
		if ( defined( $params{$field} ) ) {
			push @fields, $field;
			push @values, $params{$field};
			if ( defined( $field_map->{$field} ) ) {
				push @placeholders, $field_map->{$field};
			} else {
				push @placeholders, '?';
			}
		}
	}
	my $sql = "INSERT INTO core.users (%s) VALUES (%s)";
	eval { my $res = $this->dbh->call( sprintf( $sql, join( ", ", @fields ), join( ", ", @placeholders ) ), @values ); };
	if ($@) {
		$this->speak( "Could not add user: " . $this->dbh->dbh->errstr );
		$this->exitcode(1);
	}
} ## end sub action_user_add

sub action_user_del {
	my ( $this, %params ) = @_;
	my $username = undef;
	if ( defined( $params{__non_options__} ) && scalar( @{ $params{__non_options__} } ) ) {
		$username = $params{__non_options__}->[0];
	} else {
		$this->speak('Error: user-mod: missing login name or ID');
		$this->exitcode(1);
		return undef;
	}
	my $primary = 'login';
	if ( $username =~ /^\d+$/ ) {
		$primary = 'id';
	}
	my $sql = "DELETE FROM core.users WHERE %s = ?";
	eval { my $res = $this->dbh->call( sprintf( $sql, $primary ), $username ); };
	if ($@) {
		$this->speak( "Could not delete user: " . $this->dbh->dbh->errstr );
		$this->exitcode(1);
	}

} ## end sub action_user_del

sub action_user_mod {
	my ( $this, %params ) = @_;
	my $username = undef;
	if ( defined( $params{__non_options__} ) && scalar( @{ $params{__non_options__} } ) ) {
		$username = $params{__non_options__}->[0];
	} else {
		$this->speak('Error: user-mod: missing login name or ID');
		$this->exitcode(1);
		return undef;
	}
	my $primary = 'login';
	if ( $username =~ /^\d+$/ ) {
		$primary = 'id';
	}
	my $field_map = { password => 'MD5(?)' };
	my @fields    = ();
	my @values    = ();
	foreach my $field (qw(login password email descr name active expire)) {
		if ( defined( $params{$field} ) ) {
			my $placeholder = '?';
			if ( defined( $field_map->{$field} ) ) {
				$placeholder = $field_map->{$field};
			}
			push @fields, "$field = $placeholder";
			push @values, $params{$field};
		}
	}
	my $sql = sprintf( "UPDATE core.users SET %s WHERE %s = ?", join( ", ", @fields ), $primary );
	eval { my $res = $this->dbh->call( $sql, @values, $username ); };
	if ($@) {
		$this->speak( "Could not modify user: " . $this->dbh->dbh->errstr );
		$this->exitcode(1);
	}
} ## end sub action_user_mod

sub action_user_close {
	my ( $this, %params ) = @_;
	my $username = undef;
	if ( defined( $params{__non_options__} ) && scalar( @{ $params{__non_options__} } ) ) {
		$username = $params{__non_options__}->[0];
	} else {
		$this->speak('Error: user-close: missing login name or ID');
		$this->exitcode(1);
		return undef;
	}
	return $this->action_user_mod( __non_options__ => [$username], active => 0 );
}

sub action_user_open {
	my ( $this, %params ) = @_;
	my $username = undef;
	if ( defined( $params{__non_options__} ) && scalar( @{ $params{__non_options__} } ) ) {
		$username = $params{__non_options__}->[0];
	} else {
		$this->speak('Error: user-open: missing login name or ID');
		$this->exitcode(1);
		return undef;
	}
	return $this->action_user_mod( __non_options__ => [$username], active => 1 );
}

sub get_user_id_by_name {
	my ( $this, $name ) = @_;
	if ( $name =~ /^\d+$/ ) {
		return $name;
	}
	my $rows = $this->dbh->fetch_call( "SELECT id FROM core.users WHERE login = ?", $name );
	unless ( scalar(@$rows) ) {
		return undef;
	}
	return $rows->[0]->{id};
}

sub get_group_id_by_name {
	my ( $this, $name ) = @_;
	if ( $name =~ /^\d+$/ ) {
		return $name;
	}
	my $rows = $this->dbh->fetch_call( "SELECT id FROM core.groups WHERE group_name = ?", $name );
	unless ( scalar(@$rows) ) {
		return undef;
	}
	return $rows->[0]->{id};
}

sub action_user_group_add {
	my ( $this, %params ) = @_;
	my $username  = undef;
	my $groupname = undef;
	if ( defined( $params{__non_options__} ) && scalar( @{ $params{__non_options__} } ) ) {
		$username  = $params{__non_options__}->[0];
		$groupname = $params{__non_options__}->[1];
	}
	unless ($username) {
		$this->speak("user-group-add: missing login name or ID");
		$this->exitcode(1);
	}
	unless ($groupname) {
		$this->speak("user-group-add: missing group name or ID");
		$this->exitcode(1);
	}
	if ( $this->exitcode ) {
		return undef;
	}
	my $user_id  = $this->get_user_id_by_name($username);
	my $group_id = $this->get_group_id_by_name($groupname);
	unless ($user_id) {
		$this->speak( 'user-group-add: could not find ID for username ' . $username . '.' );
		$this->exitcode(1);
		return undef;
	}
	unless ($group_id) {
		$this->speak( 'user-group-add: could not find ID for group name ' . $groupname . '.' );
		$this->exitcode(1);
		return undef;
	}
	eval { my $res = $this->dbh->call( "INSERT INTO core.users_groups (user_id, group_id) VALUES (?, ?)", $user_id, $group_id ); };
	if ($@) {
		$this->speak( "Could not add user to group: " . $this->dbh->dbh->errstr );
		$this->exitcode(1);
	}
} ## end sub action_user_group_add

sub action_user_group_del {
	my ( $this, %params ) = @_;
	my $username  = undef;
	my $groupname = undef;
	if ( defined( $params{__non_options__} ) && scalar( @{ $params{__non_options__} } ) ) {
		$username  = $params{__non_options__}->[0];
		$groupname = $params{__non_options__}->[1];
	}
	unless ($username) {
		$this->speak("user-group-add: missing login name or ID");
		$this->exitcode(1);
	}
	unless ($groupname) {
		$this->speak("user-group-add: missing group name or ID");
		$this->exitcode(1);
	}
	if ( $this->exitcode ) {
		return undef;
	}
	my $user_id  = $this->get_user_id_by_name($username);
	my $group_id = $this->get_group_id_by_name($groupname);
	unless ($user_id) {
		$this->speak( 'user-group-add: could not find ID for username ' . $username . '.' );
		$this->exitcode(1);
		return undef;
	}
	unless ($group_id) {
		$this->speak( 'user-group-add: could not find ID for group name ' . $groupname . '.' );
		$this->exitcode(1);
		return undef;
	}
	eval { my $res = $this->dbh->call( "DELETE FROM core.users_groups WHERE user_id = ? AND group_id = ?", $user_id, $group_id ); };
	if ($@) {
		$this->speak( "Could not remove user from group: " . $this->dbh->dbh->errstr );
		$this->exitcode(1);
	}
} ## end sub action_user_group_del

sub action_group_add {
	my ( $this, %params ) = @_;
	my $groupname = undef;
	if ( defined( $params{__non_options__} ) && scalar( @{ $params{__non_options__} } ) ) {
		$groupname = $params{__non_options__}->[0];
	}
	unless ($groupname) {
		$this->speak("group-add: missing group name");
		$this->exitcode(1);
	}
	eval { my $res = $this->dbh->call( "INSERT INTO core.groups (group_name) VALUES (?)", $groupname ); };
	if ($@) {
		$this->speak( "Could not add group: " . $this->dbh->dbh->errstr );
		$this->exitcode(1);
	}
}

sub action_group_del {
	my ( $this, %params ) = @_;
	my $groupname = undef;
	if ( defined( $params{__non_options__} ) && scalar( @{ $params{__non_options__} } ) ) {
		$groupname = $params{__non_options__}->[0];
	}
	unless ($groupname) {
		$this->speak("group-del: missing group name or ID");
		$this->exitcode(1);
	}
	eval { my $res = $this->dbh->call( "INSERT INTO core.groups (group_name) VALUES (?)", $groupname ); };
	if ($@) {
		$this->speak( "Could not remove user from group: " . $this->dbh->dbh->errstr );
		$this->exitcode(1);
	}
	my $group_id = $this->get_group_id_by_name($groupname);
	unless ($group_id) {
		$this->speak( 'group-del: could not find ID for group name ' . $groupname . '.' );
		$this->exitcode(1);
		return undef;
	}
	eval { my $res = $this->dbh->call( "DELETE FROM core.groups WHERE id = ?", $group_id ); };
	if ($@) {
		$this->speak( "Could not delete group: " . $this->dbh->dbh->errstr );
		$this->exitcode(1);
	}
} ## end sub action_group_del

sub action_passwd {
	my ( $this, %params ) = @_;
	my $username = undef;
	if ( defined( $params{__non_options__} ) && scalar( @{ $params{__non_options__} } ) ) {
		$username = $params{__non_options__}->[0];
	} else {
		$this->speak('Error: passwd: missing login name');
		$this->exitcode(1);
		return undef;
	}
	my $user_id = $this->get_user_id_by_name($username);
	unless ($user_id) {
		$this->speak('Error: passwd: no user $username');
		$this->exitcode(1);
		return undef;
	}
	my ( $pw0, $pw1 );
	while ( !( $pw0 && $pw1 ) || ( $pw0 ne $pw1 ) ) {
		$pw0 = prompt( "Enter password: ", -e => "*" );
		if ( $pw0 eq '' ) {
			$this->speak("The password cannot be empty.");
			next;
		}
		$pw1 = prompt( "Retype password: ", -e => "*" );
		unless ( $pw0 eq $pw1 ) {
			$this->speak("The passwords do not match.");
			$this->exitcode(1);
			return undef;
		}
	}
	return $this->action_user_mod( __non_options__ => [$username], password => $pw0 );
} ## end sub action_passwd

sub action_help {
	my ( $this, %params ) = @_;
	my $context = 'usage';
	if ( defined( $params{__non_options__} ) && scalar( @{ $params{__non_options__} } ) ) {
		$context = $params{__non_options__}->[0];
	}
	my $ctxmap = {
		'usage' => "Usage:\n\n\t$0 [command] [parameters...] [--option=value] [--option=value] ...\n\n" . "where command is one of\n" . "\tgroup-add\t\tAdd a group\n" . "\tgroup-del\t\tDelete a group\n" . "\tgroups-list\tList available groups\n" . "\tpasswd\tInteractively change a user's password\n" . "\tusage\t\tThis screen\n" . "\tuser-add\tAdd a user\n" . "\tuser-close\tDeactivate a user's account\n" . "\tuser-del\tDelete a user\n" . "\tuser-group-add\tAdd user to a group" . "\tuser-group-del\tDelete user from a group"
		  . "\tuser-mod\tModify a user\n" 
		  . "\tuser-open\tActivate a user's account\n" 
		  . "\tusers-list\tList available users\n" 
		  . "For parameters and options, use\n\n" 
		  . "\t$0 help command\n\n" 
		  . "where command is the command you need help with.\n",
		'group-add'   => "group-add - add a group\n\n" . "Usage: $0 group-add <name>\n\n",
		'group-del'   => "group-del - delete a group\n\n" . "Usage: $0 group-del <name or id>\n\n",
		'groups-list' => "groups-list - list groups\n\n"
		  . "Usage: $0 groups-list [filter] [--user=username]\n\n"
		  . "--user list only groups to which a given user belongs.\n\n",
		'passwd'   => "passwd - interactively change a user's password\n\n" . "Usage: $0 passwd <login or id>\n\n",
		'user-add' => "user-add - add a user\n\n"
		  . "Usage: $0 user-add <login> [--password=pwd] [--email=email] [--descr=description] [--name=realname] [--active=0|1] [--expire=timestamp]\n\n"
		  . "If a password is not supplied, it will be generated automatically",
		'user-close'     => "user-close - deactivate a user\n\n" . "Usage: $0 user-close <login or id>\n\n",
		'user-del'       => "user-del - delete a user\n\n" . "Usage: $0 user-del <login or id>\n\n",
		'user-group-add' => "user-group-add - add a user to a group\n\n" . "Usage: $0 user-group-add <login or id> <group name or id>\n\n",
		'user-group-del' => "user-group-del - delete a user from a group\n\n" . "Usage: $0 user-group-del <login or id> <group name or id>\n\n",
		'user-mod'       => "user-mod - modify a user\n\n"
		  . "Usage: $0 user-mod <login or id> [--password=pwd] [--email=email] [--descr=description] [--name=realname] [--active=0|1] [--expire=timestamp]\n\n",
		'user-open'  => "user-open - activate a user\n\n" . "Usage: $0 user-open <login or id>\n\n",
		'users-list' => "users-list - list users\n\n"
		  . "Usage: $0 users-list [filter] [--active|--inactive] [--group=group_name] \n\n"
		  . "--active lists active users only\n"
		  . "--inactive lists inactive users only\n"
		  . "--group=name lists only users beloging to group name\n\n"
		  . "filter searches in logins, names, emails and description.\n\n",
	};
	if ( $ctxmap->{$context} ) {
		print STDOUT $ctxmap->{$context};
	} else {
		print STDOUT "Sorry, there is no help for this topic ($context).\n";
	}
} ## end sub action_help

sub action_unknown {
	return action_help(@_);
}

1;
